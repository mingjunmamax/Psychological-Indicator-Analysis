import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.metrics import confusion_matrixfrom sklearn.preprocessing import StandardScaler,LabelEncoderfrom sklearn.linear_model import LogisticRegressionfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_error, r2_scorefrom sklearn.svm import SVCfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDAdata = pd.read_csv("Indicators_of_Anxiety_or_Depression_Based_on_Reported_Frequency_of_Symptoms_During_Last_7_Days.csv")#phase data_1 = data[data["Indicator"]=="Symptoms of Depressive Disorder"]x1_0 = data_1[["Phase"]].values; x1_0 = [float(e[0][0:2]) for e in x1_0]data_2 = data[data["Indicator"]=="Symptoms of Anxiety Disorder"]x2_0 = data_2[["Phase"]].values; x2_0 = [float(e[0][0:2]) for e in x2_0]data_3 = data[data["Indicator"]=="Symptoms of Anxiety Disorder or Depressive Disorder"]x3_0 = data_3[["Phase"]].values; x3_0 = [float(e[0][0:2]) for e in x3_0]x1_1 = data_1[["Time Period"]].valuesx2_1 = data_2[["Time Period"]].valuesx3_1 = data_3[["Time Period"]].valuesplt.scatter(list(data_1[["Value"]].values),list(x1_0))plt.scatter(list(data_2[["Value"]].values),list(x2_0))plt.scatter(list(data_3[["Value"]].values),list(x3_0))plt.title("Distribution of Indicators based on Value and Phase ")plt.xlabel("Value")plt.ylabel("Phase")plt.legend(["Depression","Anxiety","Anxiety or Depression "])plt.show()plt.scatter(list(x1_0),list(data_1[["Time Period"]].values))plt.scatter(list(x2_0),list(data_2[["Time Period"]].values))plt.scatter(list(x3_0),list(data_3[["Time Period"]].values))plt.title("Distribution of Indicators based on Phase and Time Period")plt.xlabel("Phase")plt.ylabel("Time Period")plt.legend(["Depression","Anxiety","Anxiety or Depression "])plt.show()data_ind = data[data["Indicator"]!="Symptoms of Anxiety Disorder or Depressive Disorder"]plt.scatter(list(data_1[["Value"]].values),list(x1_0))plt.scatter(list(data_2[["Value"]].values),list(x2_0))plt.title("Distribution of Indicators based on Value and Phase")plt.xlabel("Value")plt.ylabel("Phase")plt.legend(["Depression","Anxiety"])plt.show()plt.scatter(list(x1_0),list(data_1[["Time Period"]].values))plt.scatter(list(x2_0),list(data_2[["Time Period"]].values))plt.title("Distribution of Indicators based on Phase and Time Period")plt.xlabel("Phase")plt.ylabel("Time Period")plt.legend(["Depression","Anxiety"])plt.show()# separation and prediction for anxiety or depression from single category# overlapping is the problem # this model is not great for kNN method. age = data[data["Group"]=="By Age"]age_tab = age["Indicator"].value_counts()sex = data[data["Group"]=="By Sex"]sex_tab = sex["Indicator"].value_counts()edu = data[data["Group"]=="By Education"]edu_tab = edu["Indicator"].value_counts()state = data[data["Group"]=="By State"]state_tab = state.groupby(["Indicator","State"]).count()#method 1: Logistic methoddef Logistic_Method(data):    title = list(data.columns)    data_c = data.copy(deep = True)    x = data_c.iloc[ :,0:2]    if len(title)==3:        x = data_c.iloc[ :,0:2]    else:        a = title.index("Indicator")        x = data_c.iloc[ :,0:a]    if "Phase" in title:        x1 = data_c[["Phase"]].values        x1 = [float(e[0][0:2]) for e in x1]        x1 = np.array(x1)        x.loc[ : ,"Phase"] = x1    x = x.values    y =  LabelEncoder().fit_transform(data["Indicator"].values)    x_train, x_test, y_train, y_test = train_test_split(x, y ,test_size = 0.5, random_state=0)    log_classifier = LogisticRegression()    log_classifier.fit(x_train, y_train)    y_predict = log_classifier.predict(x_test)    correctness = np.mean(y_predict==y_test)    confusion_matrix_log = confusion_matrix(y_predict, y_test)    z = log_classifier.coef_    return correctness, confusion_matrix_log, z#method 2: kNNdef kNN_method(data,i):    title = list(data.columns)    data_c = data.copy(deep = True)    if len(title)<=3:        a = title.index("Indicator")        x = data_c.iloc[ :,0:a]    else:        a = title.index("Indicator")        x = data_c.iloc[ :,0:a]    if "Phase" in title:        x1 = data_c[["Phase"]].values        x1 = [float(e[0][0:2]) for e in x1]        x1 = np.array(x1)        x.loc[ : ,"Phase"] = x1    x = x.values    y =  LabelEncoder().fit_transform(data["Indicator"].values)    kNN_scale = StandardScaler().fit(x)    x_value = kNN_scale.transform(x)    x_train, x_test, y_train, y_test = train_test_split(x, y ,test_size = 0.5, random_state=0)    neighbors_classifier = KNeighborsClassifier(n_neighbors=i)    neighbors_classifier.fit(x_train,y_train)    x_test = kNN_scale.transform(x_test)    y_predict= neighbors_classifier.predict(x_test)    accuracy = np.mean(y_predict==y_test)    ccm = confusion_matrix(y_predict, y_test)    return accuracy#logistic_s = Logistic_Method(data[["Phase","Low CI","High CI","Indicator"]])logistic_a = Logistic_Method(data[["Phase","Indicator"]])logistic_b = Logistic_Method(data[["Time Period","Indicator"]])logistic_t = Logistic_Method(data[["Phase","Time Period","Indicator"]])kNN_value = dict()kNN_a = dict()kNN_b = dict()for i in range(1,15,2):    kNN_value[i] = kNN_method(data[["Phase","Time Period","Indicator"]],i)    kNN_a[i] = kNN_method(data[["Phase","Indicator"]],i)    kNN_b[i] = kNN_method(data[["Time Period","Indicator"]],i)# Quadratic Discriminant def quadratic_discriminant(data):    title = list(data.columns)    data_c = data.copy(deep = True)    if len(title)==3:        x = data_c.iloc[ :,0:2]    else:        a = title.index("Indicator")        x = data_c.iloc[ :,0:a]    if "Phase" in title:        x1 = data_c[["Phase"]].values        x1 = [float(e[0][0:2]) for e in x1]        x1 = np.array(x1)        x.loc[ : ,"Phase"] = x1    x = x.values    x = pd.DataFrame(x)    x = x.values    labels = LabelEncoder()    y = labels.fit_transform(data[["Indicator"]].values)    x_train, x_test, y_train, y_test = train_test_split(x, y ,test_size = 0.5, random_state=0)    model = QDA()    model.fit(x_train,y_train)    y_predict = model.predict(x_test)    accuracy_rate = np.mean(y_predict==y_test)    return accuracy_rateqda_a = quadratic_discriminant(data[["Phase","Indicator"]])qda_b = quadratic_discriminant(data[["Time Period","Indicator"]])qda_r = quadratic_discriminant(data[["Phase","Time Period","Indicator"]])